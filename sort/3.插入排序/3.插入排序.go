package main

/*
	可以用 leetcode 912 测试代码
	插入排序思想：
	回想下我们平时打扑克抓牌的过程，通常我们用右手抓牌，每抓一张牌，就放到左手上，
	抓下一张牌后，会把这张牌依次与左手上的牌比较，并把它插入到一个合适的位置（通常按照牌面大小）。
	上述的过程即为插入排序的过程，假设待排序数组为a，我们从a[1]开始，让a[1]与a[0]比较，
	若a[1]较小，则让a[1]和a[0]交换位置，此时a[0]和a[1]就相当于已经放入左手中的牌。
	然后我们再让a[2]与a[1]、a[0]比较，并为它找到一个合适的位置，
	以此类推，直到为数组的最后一个元素也找到了合适的位置
*/

/*从后往前对比数据更好
因为如果数据已经是有序的   1 2 3 4 5
从后往前对比，时间复杂度为O(n)
从前往后时间复杂度变大

*/

/*
	1.插入排序的空间复杂度为 O(1)
	2.对于值相同的元素，选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，
		所以插入排序是稳定的排序算法
	3.插入排序的时间复杂度为 O(n^2)

*/

func sortArray(nums []int) {
	// 从第二个元素开始，一个个的从后往前插入
	for i := 1; i < len(nums); i++ {
		for j := i - 1; j >= 0; j-- {
			//从后往前对比数据，如果发现前面那个数据比后面那个数据大，直接交换
			//注意，这里不能使用 nums[j]和nums[i]进行比较，因为如果发生交换，交换之后nums[i]的值不再是要排序的值
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
}
