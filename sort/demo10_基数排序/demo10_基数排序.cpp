#include <iostream>
#include <string>
#include <stdlib.h>

using namespace std;

/*
	假设有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序

	思路：之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？
		手机号码有 11 位，范围太大，显然不适合用桶排序、计数排序
		采用基数排序。先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，
		以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。
		每一位的排序，要采用稳定的排序算法。

	应用：字符串的低位优先排序

	总结：
		这个思路，和极客11上订单金额和下单时间排序原理类似。
        题目是：按照订单金额排序，订单金额相同的按照下单时间排序。对所有订单的处理，订单金额是第一优先级，下单时间是第二优先级。
            如果先对所有订单按照订单金额排序，然后对订单金额相同的小区间再单独排序，代码实现很麻烦。解决方法是，使用稳定的
            排序算法，先按照下单时间排序，再按照订单金额排序。
            而对于两个手机号的比较，如果高位数字已经比较出大小，那么低位就没有比较的必要了，所以，高位数字是第一优先级，
            低位数字是第二优先级，用稳定的排序算法，先对低优先级的排序，再对高优先级的排序。
*/

/*
	基数排序：
		1，适合相同长度的数据进行排序（不相同也可以自己补成相同的长度）。
		2，按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。
			因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，
			完全不管其他位的大小关系，那么低位的排序就完全没有意义了
		3，基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，
		   如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了（要能分出高优先级和低优先级）。
		   可以选择桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，
		   那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。
*/
