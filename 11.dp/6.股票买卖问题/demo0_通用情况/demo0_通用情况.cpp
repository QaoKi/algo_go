#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

/*
    参考，https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg
    股票问题，通用条件是 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
        会加上各种限制条件，比如限制交易次数等，让你求能赚到的最大利润。

    考虑问题的【状态】，也就是说什么因素决定了可以获得的最大收益？
        1，交易的天数
        2，允许交易的次数，注意，一次交易次数，包括买入和卖出两个操作，只有买入操作会改变允许的最大交易次数。
    再看每一天的【选择】：可以选择买入、卖出或者休息。
        我们并不知道哪个操作是最好的，但是可以通过计算得到选择每个操作可以得到的最大收益。

    但是，题目中还有限制条件，规定不能同时进行多次交易，因此如果决定在第 i 天买入，在买入之前必须持有 0 份股票，
        如果决定在第 i 天卖出，在卖出之前必须恰好持有 1 份股票。
        手里是否有股票是上文提及到的隐藏【状态】，该状态影响第 i 天可以进行的操作，进而影响最大收益。
    
    基于上述条件，我们定义
        dp[i][k] 表示在第 i 天结束时，最多进行 k 次交易的情况下可以获得的最大收益。
            为什么要定义为一天的结束时，而不定义为一天的开始时呢？
                因为这一天还可以选择买、卖或者休息，只有一天结束了，才能确定经过了i天以后，最大收益是多少
        
    而根据手里是否有股票，又对 dp[i][k]的定义分成两项：
        dp[i][k][0] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益
        dp[i][k][1] 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益
    
    收益最大的情况，肯定是手里不持有股票的时候，所以，我们最终要求的就是 dp[n][K][0]
    状态转移方程：
        如何求dp[i][k][0]？
            dp[i][k][0] = max( dp[i-1][k][0], dp[i-1][k][1] + prices[i-1])
                解释：第i天结束以后，手里没有持有股票，那么有两种可能
                        1，第i-1天结束后就没有股票，在第i天选择休息
                        2，第i-1天结束后有股票，在第i天选择卖出，所以收益要加上第i天的股票价格（第i天的股票价格为 prices[i-1]）
        那么如何求dp[i-1][k][1]？（将i-1 引申为 i）
            dp[i][k][1] = max( dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1])
                解释：第i天结束以后，手里持有股票，那么有两种可能
                        1，第i-1天结束后就持有股票，在第i天选择休息
                        2，第i-1天结束后没有股票，在第i天选择买入，所以收益要减去第i天的股票价格（第i天的股票价格为 prices[i-1]）
                            并且交易次数要减1

    base case: 
        1, dp[0][k][0] = 0，
            很明显，当没有交易天数时，手里不能持有股票，所以  dp[0][k][1] = INT_MIN，定义为不可能
        2, dp[i][0][0] = 0，
            同理，没有交易次数，手里不可能持有股票，所以 dp[i][0][1] = INT_MIN，定义为不可能

*/

int main() {
    return 0;
}