#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;


/*
	题目： leetcode 96
		给定一个整数 n，求值是 1 ... n 的 n 个节点，能组成多少种二叉搜索树？

		示例 1：
			有图，见原题
*/

/*
	搜索二叉树：
		对于树上任何一个节点，它的左子树的所有结点都比这个根结点要小，它的右子树的所有结点都比这个根结点要大。
	对于给定的n，比如 n = 6，那么我们要用 1,2,3,4,5,6 来组成二叉搜索树，
		因为左子树的节点都是比根节点小的，右子树的节点都是比根节点大的，所以，我们可以考虑将问题分解。
		比如，要用 [1,2,3,4,5,6] 来构建，
			根节点可以选择 [1,2,3,4,5,6]，比如我们选择 [2]，那么左子树就为 [1]，右子树就为 [3,4,5,6]，
			将问题分解成一个更小的问题：用 [3,4,5,6] 来构建一棵二叉搜索树，
				比如再选 [5] 作为根节点，那么左子树为 [3,4]，右子树为 [6]
	定义 dp 数组：
		定义 dp[i] 表示用 i 个数字，能组成的二叉搜索树种类数量。
	状态转移方程：
		我们来看 [1,2,3]
			如果选择 [1] 作为树根，那么左子树有 dp[0] 种情况，右子树有 dp[2] 种情况，左右合起来，一共有 dp[0] * dp[2] 种情况。
			如果选择 [2] 作为树根，那么左子树有 dp[1] 种情况，右子树有 dp[1] 种情况，左右合起来，一共有 dp[1] * dp[1] 种情况。
			如果选择 [3] 作为树根，那么左子树有 dp[2] 种情况，右子树有 dp[0] 种情况，左右合起来，一共有 dp[2] * dp[0] 种情况。
		所以，dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0]

		对于 dp[i]，有 i 个节点，每次可以选择其中一个节点作为根节点，一共 i 种选择，
			如果选择第 j 个节点作为根节点（1 <= j <= i），那么左子树的节点数量为 j-1，右子树的节点数量为 i-j，
			所以，此时 dp[j] = dp[j-1] * dp[i-j]，再根据 j 的取值范围，不断的调整 j，将结果累加。
	base case：
		空节点也是一颗二叉搜索树，所以 dp[0] = 1

	时间复杂度：O(n^2)
	空间复杂度：O(n)
*/
class Solution {
public:
    int numTrees(int n) {
		vector<int> dp(n + 1, 0);
		dp[0] = 1;
		//求dp[i]
		for (int i = 1; i <= n;i++) {
			//每次取第 j 个节点作为根节点，将结果累加
			for (int j = 1; j <= i; j++) {
				dp[i] += dp[j - 1] * dp[i - j];
			}
		}
		return dp[n];
	}
};

int main()
{
	return 0;
}