package main

/*
   题目： leetcode 70
       假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
       每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
       注意：给定 n 是一个正整数。

*/

/*
   考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下公式：
       f(n) = f(n−1) + f(n−2)
   它意味着爬到第 n 级台阶的方案数是爬到第 n - 1 级台阶的方案数和爬到第 n - 2 级台阶的方案数的和。
   根据题意知，f(1) = 1，f(2) = 2
*/

/*
   方法1：递归
       画出递归树
                                       f(n)
                               f(n-1)             f(n-2)
                           f(n-2) + f(n-3)   f(n-3)  +  f(n-4)
                                       ....
       用递归树分析时间复杂度：
           时间消耗在：1，每次将n分成n-1和n-2，这块消耗很低，常量级。
                      2，每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 1，
                           从上往下，第一层的总时间消耗是 1（ f(n-1) + f(n-2) 这一个加法运算），
                           第二层的总时间消耗是 2（f(n-2)+f(n-3) 和 f(n-3)+f(n-4) 两个加法运算），
                           第三层的总时间消耗就是 2^2。依次类推，第 k 层的时间消耗就是 2^(k−1)。
                           整个算法的总的时间消耗就是每一层时间消耗之和。
                           每次减1，树的高度为 n，那么总的复杂度为 1+2+4...+2^(n-1) = 2^n - 1
                       所以，总的时间复杂度为 2^n
*/

//f(1) = 1，f(2) = 2
func climbStairs(n int) int {
	if n <= 2 {
		return n
	}
	return climbStairs(n-1) + climbStairs(n-2)
}

/*
   方法2，带「备忘录」的递归算法，记录重复节点。从递归树中可以看出，f(n-2)和f(n-3)求了多次。用一个数据结构将已知数据保存下来。
           这种方式的复杂度，已经接近动态规划了。

           复杂度：用子问题个数乘以解决一个子问题需要的时间，因为不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，
               数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)，解决一个子问题的时间为O(1)，
               所以总的时间复杂度为O(n)，空间复杂度为O(n)
*/

func digui(record []int, n int) int {
	if n <= 2 {
		return n
	}

	// 已经计算过
	if record[n] != 0 {
		return record[n]
	}

	record[n] = digui(record, n-1) + digui(record, n-2)
	return record[n]
}

func climbStairs2(n int) int {
	record := make([]int, n+1)

	return digui(record, n)
}

/*
   方法3，动态规划
       使用备忘录的递归算法，是从顶向下计算（刚才画的递归树，是从上向下延伸，从一个规模较大的原问题，
           向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」）
       而动态规划是自底向上，从问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(n)，
           这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

       已知状态转移方程 f(n) = f(n-1) + f(n-2) 和 f(1) = 1, f(2) = 2，可求出f(3)，由f(2)和f(3)，可求出f(4)....

       复杂度：
           很明显，时间复杂度为O(n)，空间复杂度为O(n)
*/

func climbStairs3(n int) int {
	if n <= 2 {
		return n
	}
	// 申请n+1个内存，值初始化为0
	// record[i]表示f[i]的值
	record := make([]int, n+1)
	record[1] = 1
	record[2] = 2
	for i := 3; i <= n; i++ {
		record[i] = record[i-1] + record[i-2]
	}
	return record[n]
}

/*
   继续优化，根据状态转移方程，可以看出，当前状态只和之前的两个状态有关，并不需要存储所有的状态，
       所以，可以进一步优化，把空间复杂度降为 O(1)
*/

func climbStairs4(n int) int {
	if n <= 2 {
		return n
	}

	m1, m2 := 1, 2
	ret := 0
	for i := 3; i <= n; i++ {
		ret = m1 + m2
		m1 = m2
		m2 = ret
	}
	return ret
}

func main() {
}
