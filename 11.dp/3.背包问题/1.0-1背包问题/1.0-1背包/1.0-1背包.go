package main

/*
   0-1背包问题：物品选或者不选，两种选择。
   背包的容量为 W，
   物品可能有多个条件，比如重量、价值。
*/

/*
   题目：
       给定一个容量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
       其中第i个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
   示例：
       N = 3, W = 4
       wt = [2, 1, 3]
       val = [4, 2, 3]
       返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。
*/

/*
   题目中的物品不可以分割，对于每个物品来说，要么装进背包，要么不装，所以叫0-1背包问题。
   确定以下内容：
       最多能装的价值是我们要求的结果值
       【状态】（影响最终结果的元素），背包的容量和在前多少个物品中挑选
       【选择】，物品装进去或者不装进去
       【base case】，当物品数量为0时，无论背包有多少容量，结果都为0，同样，如果背包容量为0，结果也直接为0
*/

/*
   方法1，暴力递归+回溯，每一件物品，要么装，要么不装，当重量满了，直接返回
*/

// w表示目前背包剩余的容量，index表示对第几个物品进行处理，currVal表示目前背包中物品的总价值
func baoli(wt, val []int, w, index, currVal int) int {
	// base case
	// 背包没有容量了，或者没有物品了
	if w == 0 || index >= len(wt) {
		return currVal
	}
	// 选择不装
	noIn := baoli(wt, val, w, index+1, currVal)
	// 选择装
	in := 0
	if w >= wt[index] {
		in = baoli(wt, val, w-wt[index], index+1, currVal+val[index])
	}

	// 返回更大的值
	if noIn > in {
		return noIn
	}
	return in
}

/*
   方法2，带「备忘录」的递归算法，记录重复节点。
       总价值是我们要求的结果值，影响总价值的是背包的容量和从前多少个物品中挑。所以是一个二维问题
       定义：
       F(N, W) = x，表示在前N个物品中选物品装进去，当背包的容量为 W 时，所能装下的最大的价值为x
       将问题分解成子问题：
           最后一个物品装或者不装，最后一个物品装了，背包的容量变小，不装，容量不变。再用剩余的容量去求前N-1个物品。
       所以状态转移方程为：
           F(N, W) = max( F(N-1, W), F(N-1, W - wt[N-1]) + val[N-1] )
               max(不装第N个物品的总价值, 装了第N个物品的总价值)，第N个物品在wt和val数组的下标为N-1
       用一个二维数组存储 F(N, W)
       dp := [][]int{}
       这里涉及一个问题，dp数组的第一维是存储N，还是存储W。
       如果第一维存储N，那么 dp[i][j] = x，表示在前i个物品中选物品装进去，当背包容量为j时，所能装下的最大的价值为x。
       如果第一维存储W，那么 dp[i][j] = x，表示在前j个物品中选物品装进去，当背包容量为i时，所能装下的最大的价值为x。
       在使用二维数组时，没有区别，但是要将空间压缩成一维数组时，有讲究，下面会讲到。
       这里就延续F(N, W)的写法，第一维存储N，第二维存储W。

       时间复杂度：O(NW)，我们一共需要计算 NW个状态的答案，
               每个状态 F(N, W) 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要做一个比较操作（常数级复杂度），
               所以一共需要 O(NW)的时间复杂度。
       空间复杂度：O(NW)
*/

func help_digui(wt, val []int, w, index, currVal int, dp [][]int) int {
	// base case，此时index的判断要改一下
	if w == 0 || index < 0 {
		return currVal
	}

	// 已经计算过
	if dp[index][w] != 0 {
		return dp[index][w]
	}

	// 选择不装
	noIn := help_digui(wt, val, w, index-1, currVal, dp)
	// 选择装
	in := 0
	if w >= wt[index] {
		in = help_digui(wt, val, w-wt[index], index-1, currVal+val[index], dp)
	}

	// 选择较大的
	dp[index][w] = noIn
	if in > noIn {
		dp[index][w] = in
	}
	return dp[index][w]
}

func use_help(wt, val []int, w int) int {
	//第一维表示从 wt 数组的前多少个物品中选物品，物品数量为 len(wt)，所以这个值不会超过 len(wt)
	//第二维表示背包容量，这个值不会超过 w
	//dp[i][j] = x，表示在前i个物品中选物品装进去，当背包容量为j时，所能装下的最大的价值为x。
	dp := make([][]int, len(wt)+1)
	for i := 0; i < len(wt)+1; i++ {
		dp[i] = make([]int, w+1)
	}

	//初始化时从前N个物品中选
	return help_digui(wt, val, w, len(wt)-1, 0, dp)
}

/*
   方法3，动态规划
       使用备忘录的递归算法，是从顶向下计算，向下逐渐分解规模，直到分解到 base case，然后逐层返回答案，这就叫「自顶向下」）
       而动态规划是自底向上，从问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(n)，
           这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。
       这里涉及一个相同的问题，就是在循环的时候，是先循环N，再循环W，还是先循环W，再循环N。
           如果先循环N，对应的dp数组的第一维存储的是N，如果先循环W，dp数组的第一维存储的是W。
           对于使用二维数组来说，都一样。反正都能把dp数组填满。
           使用一维数组时，有讲究，下面会讲到。这里就延续上面递归的写法，dp数组的第一维存储N，第二维存储W。

       状态转移方程为
           F(N, W) = max( F(N-1, W), F(N-1, W - wt[N-1]) + val[N-1] )
           F(0, N) = 0
           F(W, 0) = 0
       复杂度：
           时间复杂度为 O(NW)，空间复杂度为 O(NW)

       整体求解的框架为：
           int dp[N+1][W+1]
           dp[0][..] = 0
           dp[..][0] = 0

           for n in [1..N]:
               for w in [1..W]:
                   dp[n][w] = max(
                       把物品 n 装进背包,
                       不把物品 n 装进背包
                   )
           return dp[N][W]

           如果没有把第n个物品装入背包，那么，最大价值dp[n][w]应该等于dp[n-1][w]。继承之前的结果（剩余承重w不变）。
           如果把第n个物品装入了背包，那么dp[n][w]应该等于 dp[n-1][w - wt[n-1]] + val[n-1]（第n个物品，在wt和val数组中的下标为 n-1）
*/

func dp(wt, val []int, W int) int {
	// dp 全填入 0，base case 已初始化
	dp := make([][]int, len(wt)+1)
	for i := 0; i < len(wt)+1; i++ {
		dp[i] = make([]int, W+1)
	}

	// 自底向上填满dp
	// n表示从wt数组的前几个物品中挑选
	for n := 1; n <= len(wt); n++ {
		// w表示当前背包容量
		for w := 1; w <= W; w++ {
			// 选择不装
			noIn := dp[n-1][w]
			in := 0
			if w >= wt[n-1] {
				// 选择装，第n个物品，在wt和val数组中的下标为 n-1
				in = dp[n-1][w-wt[n-1]] + val[n-1]
			}
			dp[n][w] = noIn
			if in > noIn {
				dp[n][w] = in
			}
		}
	}
	return dp[len(wt)][W]
}

/*
   状态压缩：上面的dp，使用的二维数组，空间复杂度为O(NW)。
       观察状态转移方程，F(N, W) = max( F(N-1, W), F(N-1, W - wt[N-1]) + val[N-1] )。
                       dp数组为dp[n][w]，n是行，w是列
       我们发现，F(N-1, W)和F(N-1, W - wt[N-1])，他们有一个维度都是N-1。
       也就是说第N行的数据，只与第N-1行的数据据有关（可以借助状态转移表来理解）。那么我们可以采用一个一维数组，
           存储N-1行的 F(N-1, 0)，F(N-1, 1)，F(N-1, 2)....，F(N-1, W)，然后借助数组来求解下一行的数据。
       这里解答上面引出的问题，dp数组存储顺序的问题。第一维是存储N，还是存储W。其实都可以求解。
           我们一直采用的是第一维存储N，如果第一维存储W，
               那么 F(W, N) = max( F(W, N-1), F(W - wt[N-1], N-1) + val[N-1] )。表示第N列的数据，只与第N-1列有关。
               在转为一维数组时，就要存储第N-1列的数据 F(0, N-1)，F(1, N-1)，F(2, N-1)....，F(W, N-1)。在dp函数的
               循环中，要先循环W，不太好理解，所以我们还是采用F(N, W)的方式。
               也就是说，物品作为第一维，背包容量作为第二维

   写完函数dp2，运行发现出错。
       在函数dp2中，dp数组中存储的是上一行的数据，我们要使用上一行的数据，来求当前行的数据。
       举例来说明出现问题的原因：
           比如当前 n=3，dp数组中存储的是 n=2 时的数据，开始循环W时，每循环完一次，就用当前行的数据，替换掉上一行的数据，
               当 w 等于2，wt[n - 1]等于1时，我们在选择装的时候，需要用到 dp[w - wt[n - 1]]，也就是 dp[1] 的数据，
               但是此时 dp[1] 的数据，已经在 w 等于 1 的循环结束时，被替换成了当前行 n=3 的数据，不再是上一行 n=2 时的数据。
               出现了数据覆盖问题，所以会出问题。
           也就是说，在遍历 W 时，dp[w - wt[n - 1]] 会用到上一行较低下标的数据。不能急于替换成当前行的数据。
           解决办法：让 w 从大到小循环。如函数 dp3，不要急于替换掉上一行较低下标的数据。而是从高位下标开始替换。
   总结：
       通过该题的状态压缩，知道了第二维需要从后往前遍历，又通过后面几题，发现背包问题的状态压缩，基本没什么边界情况，
       所以可以考虑跳过二维数组，直接写一维的。
*/
func dp2(wt, val []int, W int) int {
	//申请一个一维数组，存储第N-1行的数据，F(N-1, 0)，F(N-1, 1)，F(N-1, 2)....，F(N-1, W)，一共有W+1列
	//刚开始存储的是第1行的数据（都是0）
	dp := make([]int, W+1)
	for n := 1; n <= len(wt); n++ {
		for w := 1; w <= W; w++ {
			//选择不装，继承上一行的数据
			noIn := dp[w]
			in := 0
			if w >= wt[n-1] {
				//选择装，第n个物品，在wt和val数组中的下标为 n-1
				in = dp[w-wt[n-1]] + val[n-1]
			}

			//用当前行的数据替换掉上一行的数据，下一次n循环时，用来求下一行数据
			dp[w] = noIn
			if in > noIn {
				dp[w] = in
			}
		}
	}

	//此时dp存储的是第N行的数据，把F(N, W)返回即可
	return dp[W]
}

func dp3(wt, val []int, W int) int {
	//申请一个一维数组，存储第N-1行的数据，F(N-1, 0)，F(N-1, 1)，F(N-1, 2)....，F(N-1, W)，一共有W+1列
	//刚开始存储的是第1行的数据（都是0）
	dp := make([]int, W+1)
	for n := 1; n <= len(wt); n++ {
		for w := W; w >= 1; w-- {
			//选择不装，继承上一行的数据
			noIn := dp[w]
			in := 0
			if w >= wt[n-1] {
				//选择装，第n个物品，在wt和val数组中的下标为 n-1
				in = dp[w-wt[n-1]] + val[n-1]
			}

			//用当前行的数据替换掉上一行的数据，下一次n循环时，用来求下一行数据
			dp[w] = noIn
			if in > noIn {
				dp[w] = in
			}
		}
	}

	//此时dp存储的是第N行的数据，把F(N, W)返回即可
	return dp[W]
}

func main() {

}
