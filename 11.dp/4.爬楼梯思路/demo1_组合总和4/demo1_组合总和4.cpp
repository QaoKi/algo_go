#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

/*
    题目：leetcode 377
        给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。
        请你从 nums 中找出并返回总和为 target 的元素组合的个数。
        注意，顺序不同的序列被视作不同的组合。

        示例1：
            输入：nums = [1,2,3], target = 4
            输出：7
            解释: 所有可能的组合为：
                    (1, 1, 1, 1)
                    (1, 1, 2)
                    (1, 2, 1)
                    (1, 3)
                    (2, 1, 1)
                    (2, 2)
                    (3, 1)
*/

/*
    本题题目描述说是求组合，但又说 元素相同顺序不同的组合算两个组合，其实就是求排列！
        组合不强调顺序，(1,5)和(5,1)是同一个组合。
        排列强调顺序，(1,5)和(5,1)是两个不同的排列。

    上一题 demo2_完全背包问题/demo3_组合总和 问的是组合，本题问的是排列。
    
    这道题，看似是背包问题（给定一堆物品及重量，挑选物品，凑满容量为 target 的背包）
        但是不能再用背包的思路去做了，背包不能解决排列的问题，用二维数组定义 dp，找不到解决方法。

    换个思路：
        可以把这题看做是 爬楼梯 的升级版，在爬楼梯问题中，每次只能爬 1 级台阶或者 2 级台阶，
        运用到该题中，一共有 target 级台阶，每次可以爬 num (num in nums) 级台阶，也就是说
        每次可以爬的台阶数，取决于 nums 数组中的值，求此时爬上楼顶有多少种方法。
            比如：设一共 5 级台阶，每次可以爬 1 级台阶或者 2 级台阶。
                其中一个解为 [1,2,1,1]，再找另外一个解 [1,1,2,1]，虽然这两个接的元素相同，都是 3个1，1个2，
                但是我们知道因为顺序不同，这两个是不同的解，也就是说，求的是排列。所以，爬楼梯思路很适合求排列问题。
    定义 dp 数组
        dp[i] 表示一个人跳台阶，每次可以选择跳 num 阶(num in nums),他要跳到第 i 级台阶总共有多少种跳法。
    状态转移方程
        跳到第 i 级台阶的方法数为跳到 i-num 级台阶的方法数之和，
            因为他只要跳到第 i-num 级台阶，再跳一步（num 级台阶），就可以跳到第 i 级了。
            而 num 的取值有多个，让所有的 dp[i-num] 相加，就得到 dp[i]。
        所以状态转移方程为
            dp[i] += dp[i-num], (nums[0] <= num <= nums[nums.size() - 1])
    base case
        如果台阶数为0，只有一种不跳的方法，所以 dp[0] = 1

    注意一点，leetcode 的 AC 中有越界的数据，注意排除掉

    总结：
        当问题看似是背包问题，要注意问法，如果问的是组合，那么可以用背包思路，
            如果问的是排列，用背包思路解不了，要用 “爬楼梯” 思路。
            在 demo2_完全背包问题 中，demo2_零钱兑换2 和 demo3_组合总和，问的是组合，所以可以用背包的思路解决。

        再用背包思路解组合问题时，当将空间优化到一维数组，如果仔细观察，可以发现和 爬楼梯 思路的不同
        总结一下：
            在组合问题中，外层循环是遍历物品，内层循环是遍历金额，
            而在排列问题中，外层循环是遍历金额，内层循环是遍历物品。
        不过把这个规律背下来也没用，因为说不出来为什么，
            所以，对于组合问题，我建议还是先用二维的背包思路解出来，然后再优化到一维空间，
            而对于排列问题，直接用 爬楼梯 的思路
*/

class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (i >= nums[j]) {
                    //防止 dp[i] + dp[i - nums[j]] 越界
                    //注意，不能用 dp[i] + dp[i - nums[j]] >= INT_MAX 的方式来判断
                    if (dp[i] >= INT_MAX - dp[i - nums[j]])
                        dp[i] = INT_MAX;   
                    else
                        dp[i] += dp[i - nums[j]];
                }
                
            }
        }
        return dp[target];
    }
};


int main() {
    return 0;
}