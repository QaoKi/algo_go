package main

/*
   题目：leetcode 377
       给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。
       请你从 nums 中找出并返回总和为 target 的元素组合的个数。
       注意，顺序不同的序列被视作不同的组合。

       示例1：
           输入：nums = [1,2,3], target = 4
           输出：7
           解释: 所有可能的组合为：
                   (1, 1, 1, 1)
                   (1, 1, 2)
                   (1, 2, 1)
                   (1, 3)
                   (2, 1, 1)
                   (2, 2)
                   (3, 1)
*/

/*
   本题题目描述说是求组合，但又说 元素相同顺序不同的组合算两个组合，其实就是求排列！
       组合不强调顺序，(1,5)和(5,1)是同一个组合。
       排列强调顺序，(1,5)和(5,1)是两个不同的排列。

   上一题 2.完全背包问题/3.组合总和 问的是组合，本题问的是排列。

   这道题，看似是背包问题（给定一堆物品及重量，挑选物品，凑满容量为 target 的背包）
       但是不能再用背包的思路去做了，背包不能解决排列的问题，用二维数组定义 dp，找不到解决方法。

   换个思路：
       可以把这题看做是 爬楼梯 的升级版，在爬楼梯问题中，每次只能爬 1 级台阶或者 2 级台阶，
       运用到该题中，一共有 target 级台阶，每次可以爬 num (num in nums) 级台阶，也就是说
       每次可以爬的台阶数，取决于 nums 数组中的值，求此时爬上楼顶有多少种方法。
           比如：设一共 5 级台阶，每次可以爬 1 级台阶或者 2 级台阶。
               其中一个解为 [1,2,1,1]，再找另外一个解 [1,1,2,1]，虽然这两个接的元素相同，都是 3个1，1个2，
               但是我们知道因为顺序不同，这两个是不同的解，也就是说，求的是排列。所以，爬楼梯思路很适合求排列问题。
   定义 dp 数组
       dp[i] 表示一个人跳台阶，每次可以选择跳 num 阶(num in nums),他要跳到第 i 级台阶总共有多少种跳法。
   状态转移方程
       跳到第 i 级台阶的方法数为跳到 i-num 级台阶的方法数之和，
           因为他只要跳到第 i-num 级台阶，再跳一步（num 级台阶），就可以跳到第 i 级了。
           而 num 的取值有多个，让所有的 dp[i-num] 相加，就得到 dp[i]。
       所以状态转移方程为
           dp[i] += dp[i-num], (nums[0] <= num <= nums[nums.size() - 1])
   base case
       如果台阶数为0，只有一种不跳的方法，所以 dp[0] = 1

   总结：
       当问题看似是背包问题，要注意问法，如果问的是组合，那么可以用背包思路，
           如果问的是排列，用背包思路解不了，要用 “爬楼梯” 思路。
           在 2.完全背包问题 中，2.零钱兑换2 和 3.组合总和，问的是组合，所以可以用背包的思路解决。

       再用背包思路解组合问题时，当将空间优化到一维数组后，仔细观察，可以发现和 爬楼梯 思路的不同
       总结一下：
           在组合问题中，外层循环是遍历物品，内层循环是遍历金额，
           而在排列问题中，外层循环是遍历金额，内层循环是遍历物品。
               用爬楼梯来说明的话，就是外层循环是遍历台阶数，内层循环是遍历步数
               这个也很好理解，因为前面说过了，所有的 dp[i-num] 相加后得到 dp[i]，所以外层要循环台阶数
               并且内层循环的边界要注意一下。
       总之，不能将爬楼梯的思路和背包问题混为一谈，这两个是不同的思路

       对于组合问题，我建议还是先用二维的背包思路解出来，然后再优化到一维空间，
       而对于排列问题，直接用 爬楼梯 的思路
*/

func combinationSum4(nums []int, target int) int {
	dp := make([]int, target+1)

	// base case
	dp[0] = 1
	// i 是台阶数，j 是步数
	for i := 1; i <= target; i++ {
		for j := 0; j < len(nums); j++ {
			if i >= nums[j] {
				dp[i] += dp[i-nums[j]]
			}
		}
	}
	return dp[target]
}

func main() {
}
