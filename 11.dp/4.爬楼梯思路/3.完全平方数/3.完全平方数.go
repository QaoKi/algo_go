package main

/*
	题目： leetcode 279
		给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
		给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

		完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。
			例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

		示例 1：
			输入：n = 12
			输出：3
			解释：12 = 4 + 4 + 4
		示例 2：
			输入：n = 13
			输出：2
			解释：13 = 4 + 9

*/

/*
	1，和 零钱兑换 差不多，在 零钱兑换 题目中，我们提到它的最优的子结构是
		假设我们知道组成金额S所需最少的硬币数，这些硬币中，最后一枚硬币的面值是 C。那么由于问题的最优子结构，转移方程应为：
        	F(S) = F(S - C) + 1 （只要再加一枚硬币就可以）
		然而我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值 c0，c1...cn-1，去当做最后一枚硬币，取所有结果中最小的值。

		同理，该题中，假设我们知道了组成 n 的所有完全平方数中，最后一个完全平方数是 M，那么
			F(N) = F(N - M) + 1 （只要再加一个数就可以）
		我们同样不知道 M 是多少，而且题目也没有像零钱兑换一样给出所有可选的完全平方数，
			我们要做的，是像硬币一样，枚举每个可能的完全平方数，去当做最后一个完全平方数 M，然后取所有结果中最小的值。
				完全平方数有无数个，比如1、4、9、16...，可以看出，这些完全平方数，是由 1*1, 2*2, 3*3, 4*4 求出来的，
				而且 M 肯定是小于等于n的，所以可以从 j = 1 开始遍历，求出每一个完全平方数 j*j，
				当 j*j 小于等于 n 时，去作为 M 计算
		得出状态转移方程
			dp[i] = min(dp[i], dp[i - j*j] + 1), 1 <= j*j <= i

		base case:
			因为状态转移方程中用到了 min()，所以 dp 数组的值要初始化为无穷大，和零钱兑换一样的，
				可以设为 n+1，最多需要 n 个 1，不会超过 n+1，设为 n+1 就相当于设为正无穷
			当 n 等于0 时，dp[0] = 0
*/

func min(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func numSquares(n int) int {
	dp := make([]int, n+1)
	for i := 0; i <= n; i++ {
		dp[i] = n + 1
	}

	// base case
	dp[0] = 0
	for i := 1; i <= n; i++ {
		for j := 1; j*j <= i; j++ {
			dp[i] = min(dp[i], dp[i-j*j]+1)
		}
	}
	return dp[n]
}

/*
	2，完全背包问题
		既然和零钱兑换一样，那么自然也可以作为完全背包问题看待，
		在零钱兑换问题中，完全背包的dp数组被定义为
			dp[i][j] = x，若只使用前i个硬币（物品），当背包容量为j时，最少需要 x 个物品（硬币）可以装满背包。
		在这题中，我们依然不知道 i 有多少，不过我们知道，i*i要小于等于j才有意义，
			根据这条性质，我们可以求出所有可能会用到的完全平方数

*/

func numSquares1(n int) int {
	//存放所有可能用到的完全平方数
	nums := []int{}

	i := 1
	for n >= i*i {
		nums = append(nums, i*i)
		i++
	}

	dp := make([]int, n+1)
	for i := 0; i < n+1; i++ {
		dp[i] = n + 1
	}

	// base case
	dp[0] = 0
	for i := 1; i <= len(nums); i++ {
		for j := 1; j <= n; j++ {
			if j >= nums[i-1] {
				dp[j] = min(dp[j], dp[j-nums[i-1]]+1)
			}
		}
	}
	return dp[n]
}

func main() {
}
