#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;


/*
	题目： leetcode 279
		给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
		给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

		完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。
			例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

		示例 1：
			输入：n = 12
			输出：3 
			解释：12 = 4 + 4 + 4
		示例 2：
			输入：n = 13
			输出：2
			解释：13 = 4 + 9

*/

/*
	1，和 零钱兑换 差不多，在 零钱兑换 题目中，我们提到它的最优的子结构是
		假设我们知道组成金额S所需最少的硬币数，这些硬币中，最后一枚硬币的面值是 C。那么由于问题的最优子结构，转移方程应为：
        	F(S) = F(S - C) + 1 （只要再加一枚硬币就可以）
		然而我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值 c0，c1...cn-1，去当做最后一枚硬币，取所有结果中最小的值。

		同理，该题中，假设我们知道了组成 n 的所有完全平方数中，最后一个完全平方数是 M，那么
			F(N) = F(N - M) + 1 （只要再加一个数就可以）
		我们同样不知道 M 是多少，而且题目也没有像零钱兑换一样给出所有可选的完全平方数，
			我们要做的，是像硬币一样，枚举每个可能的完全平方数，去当做最后一个完全平方数 M，然后取所有结果中最小的值。
				完全平方数有无数个，比如1、4、9、16...，可以看出，这些完全平方数，是由 1*1, 2*2, 3*3, 4*4 求出来的，
				而且 M 肯定是小于等于n的，所以可以从 j = 1 开始遍历，求出每一个完全平方数 j*j，
				当 j*j 小于等于 n 时，去作为 M 计算
		得出状态转移方程
			dp[i] = min(dp[i], dp[i - j*j] + 1), 1 <= j*j <= n 
		
		base case:
			因为状态转移方程中用到了 min()，所以 dp 数组的值要初始化为无穷大，和零钱兑换一样的，不能直接定位正无穷，
				因为后面可能会出现 dp[i - j * j] + 1 的情况，如果此时 dp[i - j * j] 等于正无穷，就越界了。
				可以设为 n+1，最多需要 n 个 1，不会超过 n+1，设为 n+1 就相当于设为正无穷
			当 n 等于0 时，dp[0] = 0
*/

class Solution {
public:
    int numSquares(int n) {
		if(n <= 0) return 0;
		vector<int> dp(n + 1, n + 1);
		dp[0] = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; i >= j * j; j++) {
				dp[i] = min(dp[i], dp[i - j * j] + 1);
			}
		}

		return dp[n];
    }
};

/*
	2，完全背包问题
		既然和零钱兑换一样，那么自然也可以作为完全背包问题看待，
		在零钱兑换问题中，完全背包的dp数组被定义为
			dp[i][j] = x，若只使用前i个硬币（物品），当背包容量为j时，最少需要 x 个物品（硬币）可以装满背包。
		在这题中，我们依然不知道 i 有多少，不过我们知道，i*i要小于等于j才有意义，
			根据这条性质，我们可以求出所有可能会用到的完全平方数
		
*/

int dp2(int n) {
	if(n <= 0) return 0;

	//存放所有可能用到的完全平方数
	vector<int> choices;
	int res = 1;

	while(n >= res * res) {
		choices.push_back(res * res);
		res++;
	}

	vector<int> dp(n + 1, n + 1);
	dp[0] = 0;

	for (int i = 1; i <= choices.size(); i++) {
		for (int j = 1; j <= n; j++) {
			//不选
            int no_in = dp[j];
            int in = INT_MAX;
            if(j >= choices[i - 1]) {
                //选出来
                in = dp[j - choices[i - 1]] + 1;
            }

            dp[j] = min(no_in, in);
		}
	}

	return dp[n];
}

int main()
{
	return 0;
}