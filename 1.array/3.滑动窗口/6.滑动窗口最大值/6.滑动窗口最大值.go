package main

/*
	题目： leetcode 239
		给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
		你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

		返回滑动窗口中k个整数中的最大值。


		示例1：
			输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
			输出：[3,3,5,5,6,7]
			解释:
				滑动窗口的位置                最大值
				---------------               -----
				[1  3  -1] -3  5  3  6  7       3 在滑动窗口中是最大值
				 1 [3  -1  -3] 5  3  6  7       3
				1  3 [-1  -3  5] 3  6  7       5
				1  3  -1 [-3  5  3] 6  7       5
				1  3  -1  -3 [5  3  6] 7       6
				1  3  -1  -3  5 [3  6  7]      7
*/

/*
	用一个双端队列，滑动窗口中的最大值，如果在滑动窗口的右边，那么，滑动窗口左边的数永远不可能成为最大值，
	所以，每次进来一个值，从队尾开始比较，依次删除左边比它小的值，这样队头的值就是最大的
	比如第一次1，3，6的时候，直接在队列中把1，3移除，只保留6，下一次进来4，比6小，保留，此时队列为 [6,4]
	再进来5，先和队尾4比较，比4大，删除4，再和6比较，比6小，保留6, 5入队。此时队列为 [6,5]。

	时间复杂度：O(n)
	空间复杂度：O(k)

*/

func maxSlidingWindow(nums []int, k int) []int {
	res := []int{}
	if len(nums) == 0 || k <= 0 {
		return res
	}

	//队列中只记录滑动窗口中元素的下标，方便判断是否该出去了
	queue := []int{}

	for i := 0; i < len(nums); i++ {

		//队列中有元素
		if len(queue) != 0 {
			//队头元素是否该出去
			if i-k >= queue[0] {
				queue = queue[1:]
			}

			//依次和队尾的数据比较，删除队尾中比nums[i]小的值
			for len(queue) != 0 && nums[queue[len(queue)-1]] < nums[i] {
				queue = queue[0 : len(queue)-1]
			}
		}

		//如果队列中没有元素，或者在上面的步骤中，将队尾中比nums[i]小的值都删除了，此时i直接入队尾
		queue = append(queue, i)

		// 开始记录窗口最大值
		if i+1 >= k {
			res = append(res, nums[queue[0]])
		}
	}

	return res
}
