package main

/*
	leetcode 48
	题目：给定一个整型正方形矩阵matrix，请把该矩阵调整成顺时针旋转90度的样子。
	例如：
			1	2	3	4
			5	6	7	8
			9	10	11	12
			13	14	15	16
	旋转以后变为：
			13	9	5	1
			14	10	6	2
			15	11	7	3
			16	12	8	4
	【要求】 额外空间复杂度为O(1)
*/

/*
	方法1，
		按圈来旋转，先转最外圈的一层，再转第二圈的。。。
			比如上例中，最外圈的数据为 (1, 2, 3, 4), (4, 8, 12, 16), (16, 15, 14, 13), (13, 9, 5, 1),
			第二层的数据为 (6, 7), (7, 11), (11, 10), (10, 6),
			这里就按顺时针的顺序表示一圈的数据了
		如何旋转？
			我们每次让4条边中的4个数完成交换，
				比如，第一次将 1, 4, 16, 13的位置交换，
				第二次将 2, 8, 15, 9的位置交换，
				第三次将 3, 12, 14, 5的位置交换。
				这样，第一层就旋转完了。上述过程中，每条边处理了3个数。
				那么，对于不同层的正方形，每一条边，需要处理多少个数呢？
					right - left个，这个数字是当前层的正方形的边长减1，为什么要减1呢，
					比如，最外层时，我们在第一次处理 1, 4, 16, 13的时候，很明显，第一行的最后一个值 4已经在第一次处理中处理过了，
					所以，不需要再处理他了，这其实类似于 左闭右开。
*/
func rotate(matrix [][]int) {
	if len(matrix) == 0 {
		return
	}

	n := len(matrix)
	top, down := 0, n-1
	left, right := 0, n-1
	for top <= down && left <= right {
		//每次分别让4条边中的4个数完成交换，这里4条边的顺序按照顺时针计算
		//第一次处理每条边的第一个数，第二次处理每条边的第二个数，第三次处理每条边的第三个数。。。
		//每一条边要处理right - left个数
		for i := 0; i < right-left; i++ {
			tmp := matrix[top][left+i]                   //先保存第一条边的数
			matrix[top][left+i] = matrix[down-i][left]   // 把第四条边的数移动到第一条
			matrix[down-i][left] = matrix[down][right-i] //把第三条边的数移动到第四条
			matrix[down][right-i] = matrix[top+i][right] //把第二条边的数移动到第三条
			matrix[top+i][right] = tmp                   //第二条边设置为第一条边的数据
		}

		//一圈转完了
		top++
		down--
		left++
		right--
	}
}

/*
	方法1的方法，难点在于，在处理4条边上的4个数时，如何找到4个数对应的坐标。
	方法2，
		先以对角线为轴进行翻转，
		比如
			1	2	3
			4	5	6
			7	8	9
		以 1 5 9 为轴翻转，翻转后为
			1	4	7
			2	5	8
			3	6	9
		再以纵轴对称翻转，这个正方形边长为奇数，所以以中间的轴 4 5 6 为对称，进行翻转，
		翻转后为
			7	4	1
			8	5	2
			9	6	3
		这样就是我们要求的答案

	这种方法的难点在于翻转的代码如何写
*/

func rotate1(matrix [][]int) {
	if len(matrix) == 0 {
		return
	}

	n := len(matrix)
	//先以对角线（左上-右下）为轴进行翻转
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}

	//先以竖轴为对称轴翻转
	for i := 0; i < n; i++ {
		for j := 0; j < n/2; j++ {
			matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
		}
	}
}
